<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>C2 Infrastructure Thorns</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- html,2,fn-in --> 
<meta name="src" content="UsersGuide.tex"> 
<meta name="date" content="2011-10-25 15:07:00"> 
<link rel="stylesheet" type="text/css" href="UsersGuide.css"> 
</head><body 
>
<!--l. 17--><div class="crosslinks"><p class="noindent">[<a 
href="UsersGuidech9.html" >prev</a>] [<a 
href="UsersGuidech9.html#tailUsersGuidech9.html" >prev-tail</a>] [<a 
href="#tailUsersGuidech10.html">tail</a>] [<a 
href="UsersGuidepa3.html#UsersGuidech10.html" >up</a>] </p></div>
<h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;C2</span><br /><a 
 id="x14-155000C2"></a>Infrastructure Thorns</h2>
     <ul class="itemize1">
     <li class="itemize"> Concepts and terminology (Overloading and registration of functions)
     </li>
     <li class="itemize"> The cGH structure &#8212; what it is and how to use it
     </li>
     <li class="itemize"> Extending the cGH structure
     </li>
     <li class="itemize"> Querying group and variable information
     </li>
     <li class="itemize"> Providing an I/O layer
     </li>
     <li class="itemize"> Providing a communication layer
     </li>
     <li class="itemize"> Providing a reduction operator
     </li>
     <li class="itemize"> Providing an interpolation operator
     </li>
     <li class="itemize"> Overloadable functions</li></ul>
<h3 class="sectionHead"><span class="titlemark">C2.1   </span> <a 
 id="x14-156000C2.1"></a>Concepts and Terminology</h3>
<!--l. 35--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">C2.1.1   </span> <a 
 id="x14-157000C2.1.1"></a>Overloading and Registration</h4>
<!--l. 37--><p class="noindent" >The flesh defines a core API which guarantees the presence of a set of functions. Although the flesh guarantees
the presence of these functions, they can be provided by thorns. Thorns do this by either the <span 
class="cmti-10">overloading </span>or the
<span 
class="cmti-10">registration </span>of functions.
<!--l. 42--><p class="noindent" >
<h5 class="subsubsectionHead"><a 
 id="x14-158000C2.1.1"></a>Overloading</h5>
                                                                                       
                                                                                       
<!--l. 44--><p class="noindent" >Some functions can only be provided by one thorn. The first thorn to <span 
class="cmti-10">overload </span>this function succeeds, and any
later attempt to overload the function fails. For each overloadable function, there is a function with a name
something like <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_Overload... </span>which is passed the function pointer.
<!--l. 50--><p class="noindent" >
<h5 class="subsubsectionHead"><a 
 id="x14-159000C2.1.1"></a>Registration</h5>
<!--l. 52--><p class="noindent" >Some functions may be provided by several thorns. The thorns <span 
class="cmti-10">register </span>their function with the flesh, and when
the flesh-provided function is called, the flesh calls all the registered functions.
<!--l. 56--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">C2.1.2   </span> <a 
 id="x14-160000C2.1.2"></a>GH Extensions</h4>
<!--l. 58--><p class="noindent" >A GH extension is a way to associate data with each cGH. This data should be data that is required to be
associated with a particular GH by a thorn.
<!--l. 61--><p class="noindent" >Each GH extension is given a unique handle.
<!--l. 63--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">C2.1.3   </span> <a 
 id="x14-161000C2.1.3"></a>I/O Methods</h4>
<!--l. 65--><p class="noindent" >An I/O method is a distinct way to output data. Each I/O method has a unique name, and the flesh-provided
I/O functions operate on all registered I/O methods.
<!--l. 68--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">C2.2   </span> <a 
 id="x14-162000C2.2"></a>GH Extensions</h3>
<!--l. 70--><p class="noindent" >A GH extension is created by calling <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_RegisterGHExtension</span>, with the name of the extension. This returns
a unique handle that identifies the extension. (This handle can be retrieved at any time by a call to
<span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_GHExtensionHandle</span>.)
<!--l. 74--><p class="noindent" >Associated with a GH extension are three functions
<!--l. 76--><p class="noindent" >
                  <dl class="list1"><dt class="list">
<span 
class="cmtt-10">SetupGH</span>           </dt><dd 
class="list">
                                                                                       
                                                                                       
                  <!--l. 77--><p class="noindent" >this is used to actually create the data structure holding the extension. It is called
                  when a new cGH is created.
                  </dd><dt class="list">
<span 
class="cmtt-10">InitGH</span>            </dt><dd 
class="list">
                  <!--l. 80--><p class="noindent" >this is used to initialise the extension. It is called after the scheduler has been
                  initialised on the cGH.
                  </dd><dt class="list">
<span 
class="cmtt-10">ScheduleTraverseGH</span><br 
class="newline" />                  </dt><dd 
class="list">
                  <!--l. 83--><p class="noindent" >this is called whenever the schedule tree is due to be traversed on the GH. It should
                  initialise the data on the cGH and the call <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_ScheduleTraverse </span>to traverse the
                  schedule tree.</dd></dl>
<!--l. 89--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">C2.3   </span> <a 
 id="x14-163000C2.3"></a>Overloadable and Registerable Functions in Main</h3>
<div class="tabular"> <table id="TBL-7" class="tabular" 
cellspacing="0" cellpadding="0" rules="groups" 
><colgroup id="TBL-7-1g"><col 
id="TBL-7-1"></colgroup><colgroup id="TBL-7-2g"><col 
id="TBL-7-2"></colgroup><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-1-1"  
class="td11"><span 
class="cmbx-10">Function        </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-1-2"  
class="td11"><span 
class="cmbx-10">Default</span></td></tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-2-1"  
class="td11"><span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_Initialise</span></span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-2-2"  
class="td11"></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-3-1"  
class="td11"><span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_Evolve</span></span>    </td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-3-2"  
class="td11">       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-4-1"  
class="td11"><span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_Shutdown</span></span>  </td><td  style="white-space:nowrap; text-align:left;" id="TBL-7-4-2"  
class="td11">       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-7-5-1"  
class="td11">               </td>
</tr></table></div>
<!--l. 99--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">C2.4   </span> <a 
 id="x14-164000C2.4"></a>Overloadable and Registerable Functions in Comm</h3>
<div class="tabular"> <table id="TBL-8" class="tabular" 
cellspacing="0" cellpadding="0" rules="groups" 
><colgroup id="TBL-8-1g"><col 
id="TBL-8-1"></colgroup><colgroup id="TBL-8-2g"><col 
id="TBL-8-2"></colgroup><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-1-1"  
class="td11"><span 
class="cmbx-10">Function                     </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-1-2"  
class="td11"><span 
class="cmbx-10">Default</span></td></tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-2-1"  
class="td11"><span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_SyncGroup</span></span> </td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-2-2"  
class="td11"></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-3-1"  
class="td11"><span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_SyncGroupsByDirI</span></span>   </td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-3-2"  
class="td11">       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-4-1"  
class="td11"><span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_EnableGroupStorage</span></span> </td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-4-2"  
class="td11">       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-5-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-5-1"  
class="td11"><span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_DisableGroupStorage</span></span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-5-2"  
class="td11">       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-6-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-6-1"  
class="td11"><span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_EnableGroupComm</span></span>    </td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-6-2"  
class="td11">       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-7-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-7-1"  
class="td11"><span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_DisableGroupComm</span></span>   </td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-7-2"  
class="td11">       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-8-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-8-1"  
class="td11"><span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_Barrier</span></span>            </td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-8-2"  
class="td11">       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-9-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-9-1"  
class="td11"><span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_Reduce</span></span>             </td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-9-2"  
class="td11">       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-10-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-10-1"  
class="td11"><span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_Interp</span></span>             </td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-10-2"  
class="td11">       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-11-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-11-1"  
class="td11"><span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_ParallelInit</span></span>       </td><td  style="white-space:nowrap; text-align:left;" id="TBL-8-11-2"  
class="td11">       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-12-"><td  style="white-space:nowrap; text-align:left;" id="TBL-8-12-1"  
class="td11">                        </td>
</tr></table></div>
<!--l. 116--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">C2.5   </span> <a 
 id="x14-165000C2.5"></a>Overloadable and Registerable Functions in I/O</h3>
                                                                                       
                                                                                       
<div class="tabular"> <table id="TBL-9" class="tabular" 
cellspacing="0" cellpadding="0" rules="groups" 
><colgroup id="TBL-9-1g"><col 
id="TBL-9-1"></colgroup><colgroup id="TBL-9-2g"><col 
id="TBL-9-2"></colgroup><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-1-"><td  style="white-space:nowrap; text-align:left;" id="TBL-9-1-1"  
class="td11"><span 
class="cmbx-10">Function                     </span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-9-1-2"  
class="td11"><span 
class="cmbx-10">Default</span></td></tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-2-"><td  style="white-space:nowrap; text-align:left;" id="TBL-9-2-1"  
class="td11"><span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_OutputGH</span></span> </td><td  style="white-space:nowrap; text-align:left;" id="TBL-9-2-2"  
class="td11"></td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-3-"><td  style="white-space:nowrap; text-align:left;" id="TBL-9-3-1"  
class="td11"><span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_OutputVarAsByMethod</span></span></td><td  style="white-space:nowrap; text-align:left;" id="TBL-9-3-2"  
class="td11">       </td>
</tr><tr 
class="hline"><td><hr></td><td><hr></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-4-"><td  style="white-space:nowrap; text-align:left;" id="TBL-9-4-1"  
class="td11">                        </td>
</tr></table></div>
<!--l. 125--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">C2.6   </span> <a 
 id="x14-166000C2.6"></a>Drivers</h3>
<!--l. 127--><p class="noindent" >The flesh does not know about memory allocation for grid variables, about how to communicate data when
synchronisation is called for, or about multiple patches or adaptive mesh refinement. All this is the job of a
driver.
<!--l. 131--><p class="noindent" >This chapter describes how to add a driver to your code.
<!--l. 133--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">C2.6.1   </span> <a 
 id="x14-167000C2.6.1"></a>Anatomy</h4>
<!--l. 135--><p class="noindent" >A driver consists of a Startup routine which creates a GH extension, registers its associated functions, and
overloads the communication functions. It may optionally register interpolation, reduction, and I/O
methods.
<!--l. 139--><p class="noindent" >A driver may also overload the default Initialisation and Evolution routines, although a simple unigrid evolver is
supplied in the flesh.
<!--l. 142--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">C2.6.2   </span> <a 
 id="x14-168000C2.6.2"></a>Startup</h4>
<!--l. 144--><p class="noindent" >A driver consists of a GH extension, and the following overloaded functions.
<!--l. 147--><p class="noindent" >
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x14-168002x1"> <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_EnableGroupStorage</span>
     </li>
     <li 
  class="enumerate" id="x14-168004x2"> <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_DisableGroupStorage</span>
     </li>
     <li 
  class="enumerate" id="x14-168006x3"> <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_ArrayGroupSizeB</span>
     </li>
     <li 
  class="enumerate" id="x14-168008x4"> <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_QueryGroupStorageB</span>
                                                                                       
                                                                                       
     </li>
     <li 
  class="enumerate" id="x14-168010x5"> <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_SyncGroup</span>
     </li>
     <li 
  class="enumerate" id="x14-168012x6"> <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_SyncGroupsByDirI</span>
     </li>
     <li 
  class="enumerate" id="x14-168014x7"> <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_EnableGroupComm</span>
     </li>
     <li 
  class="enumerate" id="x14-168016x8"> <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_DisableGroupComm</span>
     </li>
     <li 
  class="enumerate" id="x14-168018x9"> <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_Barrier</span>
     </li>
     <li 
  class="enumerate" id="x14-168020x10"> <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_OverloadParallelInit</span>
     </li>
     <li 
  class="enumerate" id="x14-168022x11"> <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_OverloadExit</span>
     </li>
     <li 
  class="enumerate" id="x14-168024x12"> <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_OverloadAbort</span>
     </li>
     <li 
  class="enumerate" id="x14-168026x13"> <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_OverloadMyProc</span>
     </li>
     <li 
  class="enumerate" id="x14-168028x14"> <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_OverloadnProcs</span></li></ol>
<!--l. 164--><p class="noindent" >The overloadable function <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_SyncGroup </span>is deprecated, a driver should instead provide a routine to overload
the more general function <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_SyncGroupsByDirI</span>.
<!--l. 168--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">C2.6.3   </span> <a 
 id="x14-169000C2.6.3"></a>The GH Extension</h4>
<!--l. 170--><p class="noindent" >The GH extension is where the driver stores all its grid-dependent information. This is stuff like any data
associated with a grid variable (e.g.&#x00A0;storage and communication state), how many grids if it is AMR, ... It is
very difficult to describe in general, but one simple example might be
                                                                                       
                                                                                       
<div class="verbatim" id="verbatim-107">
&#x00A0;<br />struct&#x00A0;SimpleExtension
&#x00A0;<br />{
&#x00A0;<br />&#x00A0;&#x00A0;/*&#x00A0;The&#x00A0;data&#x00A0;associated&#x00A0;with&#x00A0;each&#x00A0;variable&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;/*&#x00A0;data[var][timelevel][ijk]&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;void&#x00A0;***data
&#x00A0;<br />}&#x00A0;;
&#x00A0;<br />
</div>
<!--l. 184--><p class="nopar" >
<!--l. 186--><p class="noindent" >with a <span 
class="cmtt-10">SetupGH </span>routine like
                                                                                       
                                                                                       
<div class="verbatim" id="verbatim-108">
&#x00A0;<br />struct&#x00A0;SimpleExtension&#x00A0;*SimpleSetupGH(tFleshConfig&#x00A0;*config,&#x00A0;int&#x00A0;conv_level,&#x00A0;cGH&#x00A0;*GH)
&#x00A0;<br />{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;struct&#x00A0;SimpleExtension&#x00A0;*extension;
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;extension&#x00A0;=&#x00A0;NULL;
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;if(conv_level&#x00A0;&#x003C;&#x00A0;max_conv_level)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;/*&#x00A0;Create&#x00A0;the&#x00A0;extension&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;extension&#x00A0;=&#x00A0;malloc(sizeof(struct&#x00A0;SimpleExtension));
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;/*&#x00A0;Allocate&#x00A0;data&#x00A0;for&#x00A0;all&#x00A0;the&#x00A0;variables&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;extension-&#x003E;data&#x00A0;=&#x00A0;malloc(num_vars*sizeof(void**));
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;for(var&#x00A0;=&#x00A0;0&#x00A0;;&#x00A0;var&#x00A0;&#x003C;&#x00A0;num_vars;&#x00A0;var++)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;/*&#x00A0;Allocate&#x00A0;the&#x00A0;memory&#x00A0;for&#x00A0;the&#x00A0;time&#x00A0;levels&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;extension-&#x003E;data[var]&#x00A0;=&#x00A0;malloc(num_var_time_levels*sizeof(void&#x00A0;*));
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;for(time_level&#x00A0;=&#x00A0;0;&#x00A0;time_level&#x00A0;&#x003C;&#x00A0;num_var_time_level;&#x00A0;time_level++)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;/*&#x00A0;Initialise&#x00A0;the&#x00A0;data&#x00A0;to&#x00A0;NULL&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;extension-&#x003E;data[var][time_level]&#x00A0;=&#x00A0;NULL;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;return&#x00A0;extension;
&#x00A0;<br />}
&#x00A0;<br />
</div>
<!--l. 220--><p class="nopar" >
<!--l. 222--><p class="noindent" >Basically, what this example is doing is preparing a data array for use. The function can query the flesh for
information on every variable. Note that scalars should always have memory actually assigned to
them.
<!--l. 226--><p class="noindent" >An <span 
class="cmtt-10">InitGH </span>function isn&#8217;t strictly necessary, and in this case, it could just be a dummy function.
<!--l. 229--><p class="noindent" >The <span 
class="cmtt-10">ScheduleTraverseGH </span>function needs to fill out the cGH data, and then call <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_ScheduleTraverse </span>to
have the functions scheduled at that point executed on the grid
                                                                                       
                                                                                       
<div class="verbatim" id="verbatim-109">
&#x00A0;<br />int&#x00A0;SimpleScheduleTraverseGH(cGH&#x00A0;*GH,&#x00A0;const&#x00A0;char&#x00A0;*where)
&#x00A0;<br />{
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;retcode;
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;&#x00A0;var;
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;&#x00A0;gtype;
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;&#x00A0;ntimelevels;
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;&#x00A0;level;
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;&#x00A0;idir;
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;extension&#x00A0;=&#x00A0;(struct&#x00A0;SimpleExtension&#x00A0;*)GH-&#x003E;extensions[SimpleExtension];
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;for&#x00A0;(idir=0;idir&#x003C;GH-&#x003E;cctk_dim;idir++)
&#x00A0;<br />&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;GH-&#x003E;cctk_levfac[idir]&#x00A0;=&#x00A0;1;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;GH-&#x003E;cctk_nghostzones[idir]&#x00A0;=&#x00A0;extension-&#x003E;nghostzones[idir];
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;GH-&#x003E;cctk_lsh[idir]&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;=&#x00A0;extension-&#x003E;lnsize[idir];
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;GH-&#x003E;cctk_gsh[idir]&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;=&#x00A0;extension-&#x003E;nsize[idir];
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;GH-&#x003E;cctk_bbox[2*idir]&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;=&#x00A0;extension-&#x003E;lb[extension-&#x003E;myproc][idir]&#x00A0;==&#x00A0;0;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;GH-&#x003E;cctk_bbox[2*idir+1]&#x00A0;&#x00A0;&#x00A0;&#x00A0;=&#x00A0;extension-&#x003E;ub[extension-&#x003E;myproc][idir]
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;==&#x00A0;extension-&#x003E;nsize[idir]-1;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;GH-&#x003E;cctk_lbnd[idir]&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;=&#x00A0;extension-&#x003E;lb[extension-&#x003E;myproc][idir];
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;GH-&#x003E;cctk_ubnd[idir]&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;=&#x00A0;extension-&#x003E;ub[extension-&#x003E;myproc][idir];
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;}
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;for(var&#x00A0;=&#x00A0;0;&#x00A0;var&#x00A0;&#x003C;&#x00A0;extension-&#x003E;nvariables;&#x00A0;var++)
&#x00A0;<br />&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;gtype&#x00A0;=&#x00A0;CCTK_GroupTypeFromVarI(var);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;ntimelevels&#x00A0;=&#x00A0;CCTK_MaxTimeLevelsVI(var);
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;for(level&#x00A0;=&#x00A0;0;&#x00A0;level&#x00A0;&#x003C;&#x00A0;ntimelevels;&#x00A0;level++)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;switch(gtype)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;CCTK_SCALAR&#x00A0;:
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;GH-&#x003E;data[var][level]&#x00A0;=&#x00A0;extension-&#x003E;variables[var][level];
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;break;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;CCTK_GF&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;:
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;GH-&#x003E;data[var][level]&#x00A0;=
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;((pGF&#x00A0;***)(extension-&#x003E;variables))[var][level]-&#x003E;data;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;break;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;CCTK_ARRAY&#x00A0;:
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;GH-&#x003E;data[var][level]&#x00A0;=
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;((pGA&#x00A0;***)(extension-&#x003E;variables))[var][level]-&#x003E;data;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;break;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;default:
                                                                                       
                                                                                       
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;CCTK_WARN(CCTK_WARN_ALERT,"Unknown&#x00A0;group&#x00A0;type&#x00A0;in&#x00A0;SimpleScheduleTraverse");
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
&#x00A0;<br />&#x00A0;&#x00A0;}
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;retcode&#x00A0;=&#x00A0;CCTK_ScheduleTraverse(where,&#x00A0;GH,&#x00A0;NULL);
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;return&#x00A0;retcode;
&#x00A0;<br />
&#x00A0;<br />}
&#x00A0;<br />
</div>
<!--l. 292--><p class="nopar" >
<!--l. 294--><p class="noindent" >The third argument to <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_ScheduleTraverse </span>is actually a function which will be called by the scheduler
when it wants to call a function scheduled by a thorn. This function is given some information about the
function to call, and is an alternative place where the cGH can be setup.
<!--l. 299--><p class="noindent" >This function is optional, but a simple implementation might be
                                                                                       
                                                                                       
<div class="verbatim" id="verbatim-110">
&#x00A0;<br />int&#x00A0;SimpleCallFunction(void&#x00A0;*function,
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;cFunctionData&#x00A0;*fdata,
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;void&#x00A0;*data)
&#x00A0;<br />{
&#x00A0;<br />&#x00A0;&#x00A0;void&#x00A0;(*standardfunc)(void&#x00A0;*);
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;int&#x00A0;(*noargsfunc)(void);
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;switch(fdata-&#x003E;type)
&#x00A0;<br />&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;FunctionNoArgs:
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;noargsfunc&#x00A0;=&#x00A0;(int&#x00A0;(*)(void))function;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;noargsfunc();
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;break;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;FunctionStandard:
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;switch(fdata-&#x003E;language)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;LangC:
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;standardfunc&#x00A0;=&#x00A0;(void&#x00A0;(*)(void&#x00A0;*))function;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;standardfunc(data);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;break;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;LangFortran:
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;fdata-&#x003E;FortranCaller(data,&#x00A0;function);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;break;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;default&#x00A0;:
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;CCTK_WARN(CCTK_WARN_ALERT,&#x00A0;"Unknown&#x00A0;language.");
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;break;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;default&#x00A0;:
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;CCTK_WARN(CCTK_WARN_ALERT,&#x00A0;"Unknown&#x00A0;function&#x00A0;type.");
&#x00A0;<br />&#x00A0;&#x00A0;}
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;/*&#x00A0;Return&#x00A0;0,&#x00A0;meaning&#x00A0;didn&#8217;t&#x00A0;synchronise&#x00A0;*/
&#x00A0;<br />&#x00A0;&#x00A0;return&#x00A0;0;
&#x00A0;<br />}
&#x00A0;<br />
</div>
<!--l. 339--><p class="nopar" >
<!--l. 341--><p class="noindent" >The return code of the function signifies whether or not the function synchronised the groups in this functions
synchronisation list of not.
<!--l. 344--><p class="noindent" >The flesh will synchronise them if the function returns false.
<!--l. 346--><p class="noindent" >Providing this function is probably the easiest way to do multi-patch or AMR drivers.
                                                                                       
                                                                                       
<!--l. 349--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">C2.6.4   </span> <a 
 id="x14-170000C2.6.4"></a>Memory Functions</h4>
<!--l. 351--><p class="noindent" >These consist of
     <ol  class="enumerate1" >
     <li 
  class="enumerate" id="x14-170002x1"> <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_EnableGroupStorage</span>
     </li>
     <li 
  class="enumerate" id="x14-170004x2"> <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_DisableGroupStorage</span>
     </li>
     <li 
  class="enumerate" id="x14-170006x3"> <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_QueryGroupStorageB</span>
     </li>
     <li 
  class="enumerate" id="x14-170008x4"> <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_ArrayGroupSizeB</span></li></ol>
<!--l. 359--><p class="noindent" >
<h5 class="subsubsectionHead"><a 
 id="x14-171000C2.6.4"></a>En/Disable Group Storage</h5>
<!--l. 361--><p class="noindent" >These are responsible for switching the memory for all variables in a group on or off. They should return the
former state, e.g.&#x00A0;if the group already has storage assigned, they should return 1.
<!--l. 365--><p class="noindent" >In our simple example above, the enabling routine would look something like
                                                                                       
                                                                                       
<div class="verbatim" id="verbatim-111">
&#x00A0;<br />int&#x00A0;SimpleEnableGroupStorage(cGH&#x00A0;*GH,&#x00A0;const&#x00A0;char&#x00A0;*groupname)
&#x00A0;<br />{
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;extension&#x00A0;=&#x00A0;(struct&#x00A0;SimpleExtension&#x00A0;*)GH-&#x003E;extensions[SimpleExtension];
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;if(extension-&#x003E;data[first][0][0]&#x00A0;==&#x00A0;NULL)
&#x00A0;<br />&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;for(var&#x00A0;=&#x00A0;first;&#x00A0;var&#x00A0;&#x003C;=&#x00A0;last;&#x00A0;var++)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;allocate&#x00A0;memory&#x00A0;for&#x00A0;all&#x00A0;time&#x00A0;levels;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;retcode&#x00A0;=&#x00A0;0;
&#x00A0;<br />&#x00A0;&#x00A0;}
&#x00A0;<br />&#x00A0;&#x00A0;else
&#x00A0;<br />&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;retcode&#x00A0;=&#x00A0;1;
&#x00A0;<br />&#x00A0;&#x00A0;}
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;return&#x00A0;retcode;
&#x00A0;<br />}
&#x00A0;<br />
</div>
<!--l. 391--><p class="nopar" >
<!--l. 393--><p class="noindent" >The disable function is basically the reverse of the enable one.
<!--l. 395--><p class="noindent" >The <span 
class="cmtt-10">QueryGroupStorage </span>function basically returns true or false if there is storage for the group, and the
<span 
class="cmtt-10">ArrayGroupSize </span>returns the size of the grid function or array group in a particular direction.
<!--l. 399--><p class="noindent" >
<h5 class="subsubsectionHead"><a 
 id="x14-172000C2.6.4"></a>En/Disable Group Comm</h5>
<!--l. 401--><p class="noindent" >These are the communication analogues to the storage functions. Basically, they flag that communication is to
be done on that group or not, and may initialise data structures for the communication.
<!--l. 406--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">C2.7   </span> <a 
 id="x14-173000C2.7"></a>I/O Methods</h3>
                                                                                       
                                                                                       
<!--l. 409--><p class="noindent" >The flesh by itself does not provide output for grid variables or other data. Instead, it provides a mechanism for
thorns to register their own routines as I/O methods, and to invoke these I/O methods by either the flesh
scheduler or by other thorn routines.
<!--l. 414--><p class="noindent" >This chapter explains how to implement your own I/O methods and register them with the flesh.
<h4 class="subsectionHead"><span class="titlemark">C2.7.1   </span> <a 
 id="x14-174000C2.7.1"></a>I/O Method Registration</h4>
<!--l. 419--><p class="noindent" >All I/O methods have to be registered with the flesh before they can be used.
<!--l. 421--><p class="noindent" >The flesh I/O registration API provides a routine <span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_RegisterIOMethod()</span></span> to create a handle for a new I/O
method which is identified by its name (this name must be unique for all I/O methods). With such a handle, a
thorn can then register a set of functions (using the <span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_RegisterIOMethod*()</span></span> routines from the flesh) for
doing periodic, triggered, and/or unconditional output.
<!--l. 428--><p class="noindent" >The following example shows how a thorn would register an I/O method, <span 
class="cmtt-10">SimpleIO</span>, with routines to provide all
these different types of output.
                                                                                       
                                                                                       
<div class="verbatim" id="verbatim-112">
&#x00A0;&#x00A0;void&#x00A0;SimpleIO_Startup&#x00A0;(void)
&#x00A0;<br />&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;int&#x00A0;handle&#x00A0;=&#x00A0;CCTK_RegisterIOMethod&#x00A0;("SimpleIO");
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;if&#x00A0;(handle&#x00A0;&#x003E;=&#x00A0;0)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;CCTK_RegisterIOMethodOutputGH&#x00A0;(handle,&#x00A0;SimpleIO_OutputGH);
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;CCTK_RegisterIOMethodTimeToOutput&#x00A0;(handle,&#x00A0;SimpleIO_TimeToOutput);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;CCTK_RegisterIOMethodTriggerOutput&#x00A0;(handle,&#x00A0;SimpleIO_TriggerOutput);
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;CCTK_RegisterIOMethodOutputVarAs&#x00A0;(handle,&#x00A0;SimpleIO_OutputVarAs);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
&#x00A0;<br />&#x00A0;&#x00A0;}
</div>
<!--l. 445--><p class="nopar" >
<h4 class="subsectionHead"><span class="titlemark">C2.7.2   </span> <a 
 id="x14-175000C2.7.2"></a>Periodic Output of Grid Variables</h4>
<!--l. 450--><p class="noindent" >The flesh scheduler will automatically call <span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_OutputGH()</span></span> at every iteration after the <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_ANALYSIS </span>time
bin. This function loops over all I/O methods and calls their routines registered as <span class="obeylines-h"><span 
class="cmtt-10">OutputGH()</span></span> (see also Section
<a 
href="UsersGuidech9.html#x13-55000C1.2.3">C1.2.3<!--tex4ht:ref: subsec:schedule_ccl --></a>). <div class="alltt">
<!--l. 455--><p class="noindent" ><div class="obeylines-v">
<span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;SimpleIO_OutputGH</span><span 
class="cmtt-10">&#x00A0;(const</span><span 
class="cmtt-10">&#x00A0;cGH</span><span 
class="cmtt-10">&#x00A0;*</span><span 
class="cmsltt-10">GH</span><span 
class="cmtt-10">);</span>
</div>
</div> The <span class="obeylines-h"><span 
class="cmtt-10">OutputGH()</span></span> routine itself should loop over all variables living on the <span 
class="cmtt-10">GH </span>grid hierarchy, and do all necessary
output if requested (this is usually determined by I/O parameter settings).
<!--l. 463--><p class="noindent" >As its return code, it should pass back the number of variables which were output at the current iteration, or
zero if no output was done by this I/O method.
<h4 class="subsectionHead"><span class="titlemark">C2.7.3   </span> <a 
 id="x14-176000C2.7.3"></a>Triggered Output of Grid Variables</h4>
<!--l. 469--><p class="noindent" >Besides the periodic output at every so many iterations using <span class="obeylines-h"><span 
class="cmtt-10">OutputGH()</span></span>, analysis and output of grid variables
can also be done via triggers. For this, a <span class="obeylines-h"><span 
class="cmtt-10">TimeToOutput()</span></span> routine is registered with an I/O method.
This routine will be called by the flesh scheduler at every iteration before <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_ANALYSIS </span>with the
triggering variable(s) as defined in the schedule block for all <span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_ANALYSIS </span>routines (see Section
<a 
href="UsersGuidech9.html#x13-85000C1.5.4">C1.5.4<!--tex4ht:ref: scheduling:schedule_block --></a>).
                                                                                       
                                                                                       
<!--l. 476--><p class="noindent" >If the <span class="obeylines-h"><span 
class="cmtt-10">TimeToOutput()</span></span> routine decides that it is now time to do output, the flesh scheduler will invoke the
corresponding analysis routine and also request output of the triggering variable(s) using <span class="obeylines-h"><span 
class="cmtt-10">TriggerOutput()</span></span>.
<div class="alltt">
<!--l. 480--><p class="noindent" ><div class="obeylines-v">
<span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;SimpleIO_TimeToOutput</span><span 
class="cmtt-10">&#x00A0;(const</span><span 
class="cmtt-10">&#x00A0;cGH</span><span 
class="cmtt-10">&#x00A0;*</span><span 
class="cmsltt-10">GH</span><span 
class="cmtt-10">,</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmsltt-10">varindex</span><span 
class="cmtt-10">);</span>
<br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;SimpleIO_TriggerOutput</span><span 
class="cmtt-10">&#x00A0;(const</span><span 
class="cmtt-10">&#x00A0;cGH</span><span 
class="cmtt-10">&#x00A0;*</span><span 
class="cmsltt-10">GH</span><span 
class="cmtt-10">,</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmsltt-10">varindex</span><span 
class="cmtt-10">);</span>
</div>
</div> Both routines get passed the index of a possible triggering grid variable.
<!--l. 487--><p class="noindent" ><div class="obeylines-v"><span 
class="cmtt-10">TimeToOutput()</span></div> should return a non-zero value if analysis and output for <span 
class="cmsltt-10">varindex </span>should take place at the
current iteration, and zero otherwise.
<!--l. 491--><p class="noindent" ><div class="obeylines-v"><span 
class="cmtt-10">TriggerOutput()</span></div> should return zero for successful output of variable <span 
class="cmsltt-10">varindex</span>, and a negative value in case of
an error.
<h4 class="subsectionHead"><span class="titlemark">C2.7.4   </span> <a 
 id="x14-177000C2.7.4"></a>Unconditional Output of Grid Variables</h4>
<!--l. 497--><p class="noindent" >An I/O method&#8217;s <span class="obeylines-h"><span 
class="cmtt-10">OutputVarAs()</span></span> routine is supposed to do output for a specific grid variable if ever possible. It
will be invoked by the flesh I/O API routines <span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_OutputVar*()</span></span> for unconditional, non-triggered output of
grid variables (see also Section <a 
href="UsersGuidech9.html#x13-114000C1.7.2">C1.7.2<!--tex4ht:ref: sec:io --></a>).
<!--l. 502--><p class="noindent" >A function registered as an <span 
class="cmtt-10">OutputVarAs() </span>routine has the following prototype: <div class="alltt">
<!--l. 505--><p class="noindent" ><div class="obeylines-v">
<span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;SimpleIO_OutputVarAs</span><span 
class="cmtt-10">&#x00A0;(const</span><span 
class="cmtt-10">&#x00A0;cGH</span><span 
class="cmtt-10">&#x00A0;*</span><span 
class="cmsltt-10">GH</span><span 
class="cmtt-10">,</span><span 
class="cmtt-10">&#x00A0;const</span><span 
class="cmtt-10">&#x00A0;char</span><span 
class="cmtt-10">&#x00A0;*</span><span 
class="cmsltt-10">varname</span><span 
class="cmtt-10">,</span><span 
class="cmtt-10">&#x00A0;const</span><span 
class="cmtt-10">&#x00A0;char</span><span 
class="cmtt-10">&#x00A0;*</span><span 
class="cmsltt-10">alias</span><span 
class="cmtt-10">);</span>
</div>
</div> The variable to output, <span 
class="cmsltt-10">varname</span>, is given by its full name. The full name may have appended an optional I/O
options string enclosed in curly braces (with no space between the full name and the opening curly brace). In
addition to that, an <span 
class="cmsltt-10">alias </span>string can be passed which then serves the purpose of constructing a unique name for
the output file.
<!--l. 515--><p class="noindent" >The <span class="obeylines-h"><span 
class="cmtt-10">OutputVarAs()</span></span> routine should return zero if output for <span 
class="cmsltt-10">varname </span>was done successfully, or a negative error
code otherwise.
<!--l. 521--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">C2.8   </span> <a 
 id="x14-178000C2.8"></a>Checkpointing/Recovery Methods</h3>
<!--l. 524--><p class="noindent" >Like for I/O methods, checkpointing/recovery functionality must be implemented by thorns. The flesh only
                                                                                       
                                                                                       
provides specific time bins at which the scheduler will call thorns&#8217; routines, in order to perform checkpointing
and/or recovery.
<!--l. 528--><p class="noindent" >This chapter explains how to implement checkpointing and recovery methods in your thorn. For further
information, see the documentation for thorn <span 
class="cmtt-10">CactusBase/IOUtil</span>.
<!--l. 532--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">C2.8.1   </span> <a 
 id="x14-179000C2.8.1"></a>Checkpointing Invocation</h4>
<!--l. 534--><p class="noindent" >Thorns register their checkpointing routines at <span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_CPINITIAL</span></span> and/or <span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_CHECKPOINT</span></span> and/or
<span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_TERMINATE</span></span>. These time bins are scheduled right after all initial data has been set up, after every evolution
timestep, and after the last time step of a simulation, respectively. (See Section <a 
href="UsersGuidech9.html#x13-55000C1.2.3">C1.2.3<!--tex4ht:ref: subsec:schedule_ccl --></a> for a description of all
timebins). Depending on parameter settings, the checkpoint routines decide whether to write an initial data
checkpoint, and when to write an evolution checkpoint.
<!--l. 543--><p class="noindent" >Each checkpoint routine should save all information to persistent storage, which is necessary to restart the
simulation at a later time from exactly the same state. Such information would include
     <ul class="itemize1">
     <li class="itemize">the current settings of all parameters
     </li>
     <li class="itemize">the  contents  of  all  grid  variables  which  have  global  storage  assigned  and  are  not  tagged  with
     <span 
class="cmtt-10">checkpoint="no" </span>(see also Section <a 
href="UsersGuidech12.html#x17-190000D2.2.4">D2.2.4<!--tex4ht:ref: subsec:Appendix.interface-variables --></a> on page <a 
href="UsersGuidech12.html#x17-190000D2.2.4">D20<!--tex4ht:ref: subsec:Appendix.interface-variables --></a> for a list of possible tags)<br 
class="newline" />Note that grid variables should be synced before writing them to disk.
     </li>
     <li class="itemize">other relevant information such as the current iteration number and physical time, the number of
     processors, etc.</li></ul>
<!--l. 557--><p class="noindent" >
<h4 class="subsectionHead"><span class="titlemark">C2.8.2   </span> <a 
 id="x14-180000C2.8.2"></a>Recovery Invocation</h4>
<!--l. 559--><p class="noindent" >Recovering from a checkpoint is a two-phase operation for which the flesh provides distinct timebins for recovery
routines to be scheduled at:
                  <dl class="list1"><dt class="list">
<span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_RECOVER</span><span 
class="cmtt-10">_PARAMETERS</span></span><br 
class="newline" />                  </dt><dd 
class="list">
                  <!--l. 563--><p class="noindent" >This time bin is executed before <span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_STARTUP</span></span>, in which the parameter file is
                  parsed. From these parameter settings, the recovery routines should decide whether
                  recovery was requested, and if so, restore all parameters from the checkpoint file
                  and overwrite those which aren&#8217;t steerable.<br 
class="newline" />The flesh loops over all registered recovery routines to find out whether recovery was
                                                                                       
                                                                                       
                  requested. Each recovery routine should, therefore, return a positive integer value
                  for successful parameter recovery (causing a shortcut of the loop over all registered
                  recovery routines), zero for no recovery, or a negative value to flag an error.<br 
class="newline" />If recovery was requested, but no routine could successfully recover parameters,
                  the flesh will abort the run with an error message. If no routine recovered any
                  parameters, i.e. if all parameter recovery routines returned zero, then this indicates
                  that this run is not a recovery run.<br 
class="newline" />If                                         parameter                                         recovery
                  was performed successfully, the scheduler will set the <span 
class="cmtt-10">recovered </span>flag which&#8212;in
                  combination with the setting of the <span 
class="cmtt-10">Cactus::recovery</span><span 
class="cmtt-10">_mode </span>parameter&#8212;decides
                  whether any thorn routine scheduled for <span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_INITIAL</span></span> and <span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_POSTINITIAL</span></span>
                  will be called. The default is to not execute these initial time bins during recovery,
                  because the initial data will be set up from the checkpoint file during the following
                  <span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_RECOVER</span><span 
class="cmtt-10">_VARIABLES</span></span> time bin.
                  </dd><dt class="list">
<span class="obeylines-h"><span 
class="cmtt-10">CCTK</span><span 
class="cmtt-10">_RECOVER</span><span 
class="cmtt-10">_VARIABLES</span></span><br 
class="newline" />                  </dt><dd 
class="list">
                  <!--l. 585--><p class="noindent" >Recovery  routines  scheduled  for  this  time  bin  are  responsible  for  restoring  the
                  contents of all grid variables with storage assigned from the checkpoint.<br 
class="newline" />Depending on the setting of <span 
class="cmtt-10">Cactus::recovery</span><span 
class="cmtt-10">_mode</span>, they should also decide how
                  to treat errors in recovering individual grid variables. Strict recovery (which is the
                  default) requires all variables to be restored successfully (and will stop the code
                  if not), whereas a relaxed mode could, e.g. allow for grid variables, which are not
                  found in the checkpoint file, to be gracefully ignored during recovery.</dd></dl>
<!--l. 599--><p class="noindent" >
<h3 class="sectionHead"><span class="titlemark">C2.9   </span> <a 
 id="x14-181000C2.9"></a>Clocks for Timing</h3>
<!--l. 602--><p class="noindent" >To add a Cactus clock, you need to write several functions to provide the timer functionality (see Section
<a 
href="UsersGuidech9.html#x13-127000C1.9.1">C1.9.1<!--tex4ht:ref: sec:timers --></a>), and then register these functions with the flesh as a named clock.
<!--l. 606--><p class="noindent" >The function pointers are placed in function pointer fields of a <span 
class="cmtt-10">cClockFuncs </span>structure. The fields of this
structure are are:
<!--l. 609--><p class="noindent" >
                  <dl class="list1"><dt class="list">
<span class="obeylines-h"><span 
class="cmtt-10">create</span></span>            </dt><dd 
class="list">
                  <!--l. 611--><p class="noindent" ><span class="obeylines-h"><span 
class="cmtt-10">void *(*create)(int)</span></span>
                  </dd><dt class="list">
<span class="obeylines-h"><span 
class="cmtt-10">destroy</span></span>           </dt><dd 
class="list">
                  <!--l. 612--><p class="noindent" ><span class="obeylines-h"><span 
class="cmtt-10">void (*destroy)(int, void *)</span></span>
                  </dd><dt class="list">
<span class="obeylines-h"><span 
class="cmtt-10">start</span></span>             </dt><dd 
class="list">
                  <!--l. 613--><p class="noindent" ><span class="obeylines-h"><span 
class="cmtt-10">void (*start)(int, void *)</span></span>
                                                                                       
                                                                                       
                  </dd><dt class="list">
<span class="obeylines-h"><span 
class="cmtt-10">stop</span></span>              </dt><dd 
class="list">
                  <!--l. 614--><p class="noindent" ><span class="obeylines-h"><span 
class="cmtt-10">void (*stop)(int, void *)</span></span>
                  </dd><dt class="list">
<span class="obeylines-h"><span 
class="cmtt-10">reset</span></span>             </dt><dd 
class="list">
                  <!--l. 615--><p class="noindent" ><span class="obeylines-h"><span 
class="cmtt-10">void (*reset)(int, void *)</span></span>
                  </dd><dt class="list">
<span class="obeylines-h"><span 
class="cmtt-10">get</span></span>               </dt><dd 
class="list">
                  <!--l. 616--><p class="noindent" ><span class="obeylines-h"><span 
class="cmtt-10">void (*get)(int, void *, cTimerVal *)</span></span>
                  </dd><dt class="list">
<span class="obeylines-h"><span 
class="cmtt-10">set</span></span>               </dt><dd 
class="list">
                  <!--l. 617--><p class="noindent" ><span class="obeylines-h"><span 
class="cmtt-10">void (*set)(int, void *, cTimerVal *)</span></span>
                  </dd><dt class="list">
<span class="obeylines-h"><span 
class="cmtt-10">n</span><span 
class="cmtt-10">_vals</span></span>            </dt><dd 
class="list">
                  <!--l. 618--><p class="noindent" ><span class="obeylines-h"><span 
class="cmtt-10">int</span></span>
                  </dd></dl>
<!--l. 622--><p class="noindent" >The first <span 
class="cmtt-10">int </span>argument of the functions may be used in any way you see fit.
<!--l. 625--><p class="noindent" >The <span 
class="cmtt-10">n</span><span 
class="cmtt-10">_vals </span>field holds the number of elements in the <span 
class="cmtt-10">vals </span>array field of the <span 
class="cmtt-10">cTimerVal </span>structure used by your
timer (usually 1).
<!--l. 629--><p class="noindent" >The return value of the <span 
class="cmtt-10">create </span>function will be a pointer to a new structure representing your
clock.
<!--l. 632--><p class="noindent" >The second <span 
class="cmtt-10">void* </span>argument of all the other functions will be the pointer returned from the <span 
class="cmtt-10">create</span>
function.
<!--l. 635--><p class="noindent" >The <span 
class="cmtt-10">get </span>and <span 
class="cmtt-10">set </span>functions should write to and read from (respectively) a structure pointed to by the
<span 
class="cmtt-10">cTimerVal* </span>argument:
                                                                                       
                                                                                       
<div class="verbatim" id="verbatim-113">
typedef&#x00A0;enum&#x00A0;{val_none,&#x00A0;val_int,&#x00A0;val_long,&#x00A0;val_double}&#x00A0;cTimerValType;
&#x00A0;<br />
&#x00A0;<br />typedef&#x00A0;struct
&#x00A0;<br />{
&#x00A0;<br />&#x00A0;&#x00A0;cTimerValType&#x00A0;type;
&#x00A0;<br />&#x00A0;&#x00A0;const&#x00A0;char&#x00A0;*heading;
&#x00A0;<br />&#x00A0;&#x00A0;const&#x00A0;char&#x00A0;*units;
&#x00A0;<br />&#x00A0;&#x00A0;union
&#x00A0;<br />&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;int&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;i;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;long&#x00A0;int&#x00A0;&#x00A0;&#x00A0;l;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;double&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;d;
&#x00A0;<br />&#x00A0;&#x00A0;}&#x00A0;val;
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;seconds;
&#x00A0;<br />&#x00A0;&#x00A0;double&#x00A0;resolution;
&#x00A0;<br />}&#x00A0;cTimerVal;
</div>
<!--l. 655--><p class="nopar" >
<!--l. 657--><p class="noindent" >The <span 
class="cmtt-10">heading </span>field is the name of the clock, the <span 
class="cmtt-10">units </span>field holds a string describing the type held in the <span 
class="cmtt-10">val</span>
field, and the <span 
class="cmtt-10">seconds </span>field is the time elapsed in seconds. The <span 
class="cmtt-10">resolution </span>field is the smallest non-zero
difference in values of two calls to the timer, in seconds. For example, it could reflect that the clock saves the
time value internally as an integer value representing milliseconds.
<!--l. 665--><p class="noindent" >To name and register the clock with the flesh, call the function <div class="alltt">
<!--l. 666--><p class="noindent" ><div class="obeylines-v">
<span 
class="cmtt-10">CCTK_ClockRegister(</span><span 
class="cmtt-10">&#x00A0;"</span><span 
class="cmsltt-10">my_clock_name</span><span 
class="cmtt-10">",</span><span 
class="cmtt-10">&#x00A0;&amp;</span><span 
class="cmsltt-10">clock_func</span><span 
class="cmtt-10">&#x00A0;).</span>
</div>
</div>
                                                                                       
                                                                                       
                                                                                       
                                                                                       
                                                                                       
                                                                                       
                                                                                       
                                                                                       
                                                                                       
                                                                                       
<!--l. 11--><div class="crosslinks"><p class="noindent">[<a 
href="UsersGuidech9.html" >prev</a>] [<a 
href="UsersGuidech9.html#tailUsersGuidech9.html" >prev-tail</a>] [<a 
href="UsersGuidech10.html" >front</a>] [<a 
href="UsersGuidepa3.html#UsersGuidech10.html" >up</a>] </p></div>
<!--l. 11--><p class="noindent" ><a 
 id="tailUsersGuidech10.html"></a> 
</body></html> 
